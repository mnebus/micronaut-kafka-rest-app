package com.aptvantage

import io.micronaut.context.ApplicationContext
import io.micronaut.http.HttpRequest
import io.micronaut.http.client.RxHttpClient
import io.micronaut.runtime.server.EmbeddedServer
import org.apache.kafka.clients.admin.AdminClient
import org.apache.kafka.clients.admin.AdminClientConfig
import org.apache.kafka.clients.admin.NewTopic
import org.testcontainers.containers.KafkaContainer
import org.testcontainers.utility.DockerImageName
import spock.lang.Shared
import spock.lang.Specification
import spock.util.concurrent.PollingConditions

import java.util.concurrent.TimeUnit

class TestContainersKafkaITSpec extends Specification {

    PollingConditions conditions = new PollingConditions(timeout: 10)

    @Shared
    KafkaContainer kafkaContainer

    @Shared
    EmbeddedServer embeddedServer

    @Shared
    KafkaClientConsumer kafkaClientConsumer

    @Shared
    RxHttpClient httpClient

    def setupSpec() {
        //start kafka
        kafkaContainer = new KafkaContainer(DockerImageName.parse("confluentinc/cp-kafka:5.4.3"))
        kafkaContainer.start()

        // create required topic
        AdminClient adminClient = AdminClient.create(Map.of(AdminClientConfig.BOOTSTRAP_SERVERS_CONFIG, kafkaContainer.getBootstrapServers()))
        adminClient.createTopics(List.of(new NewTopic('integration-test-topic-1', 3, (short) 1)))

        // start micronaut container with bootstrapServers generated by kafkaContainer
        Map<String, Object> properties = new HashMap<>()
        properties.put('kafka.bootstrap.servers', kafkaContainer.getBootstrapServers())
        embeddedServer = ApplicationContext.run(EmbeddedServer, properties)
        embeddedServer.start()

        // create http client with a base url of the embedded server
        httpClient = RxHttpClient.create(embeddedServer.getURL())

        // create reference to consumer
        kafkaClientConsumer = embeddedServer.getApplicationContext().getBean(KafkaClientConsumer)
    }

    def setup() {
        kafkaClientConsumer.messages.clear()
    }

    def cleanupSpec() {
        embeddedServer.stop()
        kafkaContainer.stop()
    }

    void 'messages are produced to and consumed from a topic'() {
        given: 'A message'
        Message expectedMessage = new Message(
                key: 'key-value',
                otherStuff: [
                        hello: 'tester'
                ]
        )

        when: 'A message is sent to the controller'
        httpClient.toBlocking().retrieve(HttpRequest.POST('/produce/integration-test-topic-1', expectedMessage))

        then: 'That message is produced and consumed'
        expectedMessage == kafkaClientConsumer.messages.poll(10, TimeUnit.SECONDS)
    }

}
